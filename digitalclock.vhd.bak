library ieee;
use ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all;
use ieee.std_logic_arith.all;
entity DigitalClock is port(
	soundclk:in std_logic;	--è¾“å…¥æ—¶é’Ÿé¢‘ç‡ ç›®å‰ä¸?00K
	turnOn1:in std_logic;		--å¯åŠ¨ä¿¡å· é«˜æœ‰æ•ˆï¼Œé»˜è®¤åº”å½“ä¸? 
	turnOn2:in std_logic;
	spk:out std_logic			--æ‰¬å£°å™¨é¢‘ç‡è¾“å‡?
);
end entity;

architecture behav of DigitalClock is
signal clk: std_logic_vector(3 downto 0):="0000";		--éŸ³é¢‘è¾“å‡ºæ—¶é—´è®¡æ•°å™?
signal reset: std_logic:='0'; 	--å¤ä½ä¿¡å· ä½æœ‰æ•?
signal waveout: std_logic;       --è¾“å‡ºä¿¡å·
signal freq: std_logic_vector(1 downto 0);
signal soundcnt:std_logic_vector(1 downto 0);				--clkå‘¨æœŸè®¡æ•°å™?
signal dotcnt:std_logic_vector(2 downto 0) ;		--éŸ³ç¬¦åºå·è®¡æ•°
signal melody:std_logic;

constant spkout:std_logic_vector(3 downto 0):="1111"; --é—¹é’Ÿ10Hz,2.5K
constant do:std_logic_vector(1 downto 0):="10";
constant mi:std_logic_vector(1 downto 0):="11";
constant non:std_logic_vector(1 downto 0):="00"; --æ— é¢‘ç‡å€?

begin
	spk <= waveout;

	process(soundclk)
	begin
		if (soundclk'event and soundclk='1') then
		
		--éŸ³è°ƒæ§åˆ¶
			if ((turnOn1 = '1' or turnOn2 = '1') and reset = '0') then reset <= '1'; dotcnt <= "000";		--å¼€å§‹æ’­æ”?

				
				
					case turnOn1 is			
						when '1' => melody<= '0'; 
						when others => melody<= '1'; 
					end case;
				
				
				
				
			end if;
				--é—¹é’Ÿå•éŸ³
			if clk = spkout 		--è¾“å‡ºè®¡æ•°å™¨è¾¾åˆ°å‘¨æœŸï¼Œå¼€å§‹æ›´æ”¹éŸ³è°?
				then clk <= "0000";
			
				if reset = '1' then
				case melody is
					when '0' =>																	--å¦‚æœå¤„äºæ’­æ”¾çŠ¶æ€ï¼Œå¼€å§‹æ›´æ”¹éŸ³è°?
					case dotcnt is			
						when "000" => freq <= mi; dotcnt <= dotcnt + 1;
						when "001" => freq <= do; dotcnt <= dotcnt + 1;
						when "010" => freq <= mi; dotcnt <= dotcnt + 1;
						when "011" => freq <= do; dotcnt <= dotcnt + 1;
						when "100" => freq <= mi; dotcnt <= dotcnt + 1;
						when "101" => freq <= do; dotcnt <= dotcnt + 1;
						when "110" => freq <= mi; dotcnt <= dotcnt + 1;
						when "111" => freq <= do; dotcnt <="000"; reset <= '0';
						when others => freq <= non; dotcnt <= "000"; reset <= '0';
					end case;
				
				 	when others =>																--å¦‚æœå¤„äºæ’­æ”¾çŠ¶æ€ï¼Œå¼€å§‹æ›´æ”¹éŸ³è°?
					case dotcnt is			
						when "000" => freq <= mi; dotcnt <= dotcnt + 1;
						when "001" => freq <= do; dotcnt <= dotcnt + 1;
						when "010" => freq <= mi; dotcnt <= dotcnt + 1;

						when "100" => freq <= mi; dotcnt <= dotcnt + 1;
						when "101" => freq <= do; dotcnt <= dotcnt + 1;
						when "111" => freq <= do;dotcnt <= "000"; reset <= '0';
						when others => freq <= non; dotcnt <= "000"; reset <= '0';
					end case;
				end case;
				
				end if;
			else clk <= clk + 1;
			end if;
		--ç»“æŸ
		
		--éŸ³é¢‘è¾“å‡º
			if reset = '1' then 
				if freq = non 			--æ²¡æœ‰è¾“å…¥åˆ™ä¸å“?
					then waveout <= '0';			--å‡è®¾è¾“å‡ºä½åˆ™èœ‚é¸£å™¨ä¸å“?
				else
					if soundcnt = freq 		--è®¡æ•°å™¨è¾¾åˆ°å‘¨æœ?
						then soundcnt <= "00";
						waveout <= not waveout;	--è¾“å‡ºå–åï¼Œè¾“å‡ºæ–¹æ³?
					else soundcnt <= soundcnt + 1;
					end if;
				end if;
			
			else --å¤ä½ä¿¡å·æœ‰æ•ˆæ—?
				waveout <= '0';
				soundcnt <= "00";
			end if;
		--ç»“æŸ
		end if;
	end process;
end architecture;